# å®¹å™¨åŒ–éƒ¨ç½² minerU

ðŸŒ¹

æ­¤é•œåƒæä¾›äº†æ ‡å‡†åŒ–çš„**API æŽ¥å£** ï¼Œè®©æ‚¨èƒ½å¤Ÿä¾¿æ·åœ°é€šè¿‡ **API è°ƒç”¨æ–¹å¼** è®¿é—®å’Œä½¿ç”¨æ‰€æœ‰åŠŸèƒ½ã€‚

æœ¬æŒ‡å—è¯¦ç»†é˜è¿°äº†åœ¨å…±ç»©ç®—åŠ›å¹³å°ä¸Šï¼Œé«˜æ•ˆéƒ¨ç½²ä¸Žä½¿ç”¨ minerU API é¡¹ç›®çš„æŠ€æœ¯æ–¹æ¡ˆã€‚minerU æ˜¯ä¸€æ¬¾å°† PDF è½¬åŒ–ä¸ºæœºå™¨å¯è¯»æ ¼å¼çš„å·¥å…·ï¼ˆå¦‚ markdownã€jsonï¼‰ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°è¾“å‡ºä¸ºä»»æ„æ ¼å¼ã€‚

## 1.åœ¨å…±ç»©ç®—åŠ›ä¸Šè¿è¡Œ minerU API

Section titled â€œ1.åœ¨å…±ç»©ç®—åŠ›ä¸Šè¿è¡Œ minerU APIâ€

å…±ç»©ç®—åŠ›å¹³å°æä¾›é¢„æž„å»ºçš„ minerU å®¹å™¨é•œåƒï¼Œç”¨æˆ·æ— éœ€æœ¬åœ°å¤æ‚çŽ¯å¢ƒé…ç½®ï¼Œå¯å¿«é€Ÿå®Œæˆéƒ¨ç½²å¹¶å¯ç”¨æœåŠ¡ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†éƒ¨ç½²æ­¥éª¤ï¼š

### 1.1 åˆ›å»ºéƒ¨ç½²æœåŠ¡

Section titled â€œ1.1 åˆ›å»ºéƒ¨ç½²æœåŠ¡â€

ç™»å½•[å…±ç»©ç®—åŠ›æŽ§åˆ¶å°](https://console.suanli.cn/)ï¼Œåœ¨æŽ§åˆ¶å°é¦–é¡µç‚¹å‡»â€œå¼¹æ€§éƒ¨ç½²æœåŠ¡â€è¿›å…¥ç®¡ç†é¡µé¢ã€‚é¦–æ¬¡ä½¿ç”¨éœ€ç¡®ä¿è´¦æˆ·å·²å¼€é€šå¼¹æ€§éƒ¨ç½²æœåŠ¡æƒé™ã€‚

![](/assets/NMj0bDGLXoH7wjxs0Aoc6roxng6.png)

### 1.2 é€‰æ‹© GPU åž‹å·

Section titled â€œ1.2 é€‰æ‹© GPU åž‹å·â€

æ ¹æ®å®žé™…éœ€æ±‚é€‰æ‹© GPU åž‹å·ï¼š

åˆæ¬¡ä½¿ç”¨æˆ–è°ƒè¯•é˜¶æ®µï¼ŒæŽ¨èé…ç½®å•å¼  NVIDIA RTX 4090 GPU

![](/assets/IVgTbCO2uocxiMxVwUac6ixKnPb.png)

### 1.3 é€‰æ‹©é¢„åˆ¶é•œåƒ

Section titled â€œ1.3 é€‰æ‹©é¢„åˆ¶é•œåƒâ€

åœ¨â€œæœåŠ¡é…ç½®â€æ¨¡å—åˆ‡æ¢è‡³â€œé¢„åˆ¶æœåŠ¡â€é€‰é¡¹å¡ï¼Œæœç´¢å¹¶é€‰æ‹© minerU å®˜æ–¹é•œåƒã€‚

### 1.4 éƒ¨ç½²å¹¶è®¿é—®æœåŠ¡

Section titled â€œ1.4 éƒ¨ç½²å¹¶è®¿é—®æœåŠ¡â€

ç‚¹å‡»â€œéƒ¨ç½²æœåŠ¡â€ï¼Œå¹³å°å°†è‡ªåŠ¨æ‹‰å–é•œåƒå¹¶å¯åŠ¨å®¹å™¨ã€‚

![](/assets/AlaKbEaOxoUCtYx2wDzcor8unYd.png)

éƒ¨ç½²å®ŒæˆåŽï¼Œåœ¨â€œå¿«æ·è®¿é—®â€ä¸­å¤åˆ¶ç«¯å£ä¸º 8000 çš„å…¬ç½‘è®¿é—®é“¾æŽ¥ï¼ŒåŽç»­æ˜¯é€šè¿‡è¯¥åœ°å€è°ƒç”¨ API æœåŠ¡ã€‚

åœ°å€åŽé¢åŠ ä¸Š /docs è¿›å…¥ API æŽ¥å£æ–‡æ¡£

![](/assets/ObQrbisFBo0MU6xMDvKc6Fl1nJd.png)

## 2.å¿«é€Ÿä¸Šæ‰‹â€”â€” API ä½¿ç”¨è¯´æ˜Ž

Section titled â€œ2.å¿«é€Ÿä¸Šæ‰‹â€”â€” API ä½¿ç”¨è¯´æ˜Žâ€

### 2.1 æŽ¥å£åŠŸèƒ½

Section titled â€œ2.1 æŽ¥å£åŠŸèƒ½â€

`POST /pdf_parse` HTTP æ–¹æ³•ä¸º POSTï¼Œè·¯ç”±è·¯å¾„ä¸º `/pdf_parse`ã€‚

`Parse PDF file` æ ¸å¿ƒåŠŸèƒ½ï¼šâ€‹è§£æž PDF æ–‡ä»¶â€‹ï¼Œå°†å…¶å†…å®¹è½¬æ¢ä¸º JSON å’Œ Markdown æ ¼å¼ã€‚

### 2.2 åŠŸèƒ½è¯¦ç»†è¯´æ˜Ž

Section titled â€œ2.2 åŠŸèƒ½è¯¦ç»†è¯´æ˜Žâ€

æ ¸å¿ƒè¿‡ç¨‹â€‹ï¼š å°† PDF è§£æžä¸º JSON å’Œ Markdownï¼Œè¾“å‡ºåˆ°æŒ‡å®šç›®å½•ã€‚

å‚æ•°è¯´æ˜Žâ€‹ï¼š

  * `pdf_file` (å¿…ä¼ ) PDF æ–‡ä»¶äºŒè¿›åˆ¶æ•°æ®ï¼ˆé€šè¿‡è¡¨å•ä¸Šä¼ ï¼‰ã€‚
  * `parse_method` (å¯é€‰) è§£æžæ¨¡å¼ï¼Œå¯é€‰ `auto`ï¼ˆè‡ªåŠ¨ï¼‰ã€`ocr`ï¼ˆå…‰å­¦è¯†åˆ«ï¼‰ã€`txt`ï¼ˆæ–‡æœ¬æå–ï¼‰ã€‚é»˜è®¤ `auto`ï¼Œè‹¥æ•ˆæžœä¸ä½³å»ºè®®å°è¯• `ocr`ã€‚
  * `model_json_path` (å¯é€‰) è‡ªå®šä¹‰è§£æžæ¨¡åž‹è·¯å¾„ã€‚è‹¥ä¸ºç©ºï¼Œä½¿ç”¨å†…ç½®æ¨¡åž‹ã€‚æ³¨â€‹ï¼šæ¨¡åž‹éœ€ä¸Ž PDF æ–‡ä»¶åŒ¹é…ã€‚
  * `is_json_md_dump` (å¯é€‰) æ˜¯å¦è¾“å‡º JSON/MD æ–‡ä»¶ï¼Œé»˜è®¤ `true`ï¼ˆç”Ÿæˆï¼‰ã€‚
  * `output_dir` (å¯é€‰) è¾“å‡ºç›®å½•ï¼Œé»˜è®¤ä¸º `output`ã€‚ç³»ç»Ÿä¼šæŒ‰ PDF æ–‡ä»¶ååˆ›å»ºå­ç›®å½•å­˜æ”¾ç»“æžœã€‚



è¾“å‡ºè§„åˆ™â€‹ï¼š

ç”Ÿæˆ 3 ä¸ªé˜¶æ®µæ€§ JSON æ–‡ä»¶â€‹ï¼ˆä¸åŒè§£æžé˜¶æ®µï¼‰

ç”Ÿæˆ 1 ä¸ªæœ€ç»ˆ Markdown æ–‡ä»¶â€‹ï¼ˆ`.md`ï¼‰

### 2.3 æŽ¥å£å‚æ•°ï¼ˆè¯·æ±‚éƒ¨åˆ†ï¼‰â€‹

Section titled â€œ2.3 æŽ¥å£å‚æ•°ï¼ˆè¯·æ±‚éƒ¨åˆ†ï¼‰â€‹â€

#### 2.3.1 Query å‚æ•°ï¼ˆURL å‚æ•°ï¼‰â€‹

Section titled â€œ2.3.1 Query å‚æ•°ï¼ˆURL å‚æ•°ï¼‰â€‹â€

**å‚æ•°å**| **ç±»åž‹**| **ä½ç½®**| **é»˜è®¤å€¼**| **è¯´æ˜Ž**  
---|---|---|---|---  
parse_method| string| query| auto| è§£æžæ¨¡å¼ï¼ˆauto/ocr/txtï¼‰  
model_json_path| string| query| model_json_path| è‡ªå®šä¹‰æ¨¡åž‹æ–‡ä»¶è·¯å¾„  
is_json_md_dump| boolean| query| TRUE| æ˜¯å¦è¾“å‡º JSON/MD æ–‡ä»¶  
output_dir| string| query| output| ç»“æžœè¾“å‡ºç›®å½•  
  
#### 2.3.2 Body å‚æ•°ï¼ˆè¡¨å•æ•°æ®ï¼‰â€‹

Section titled â€œ2.3.2 Body å‚æ•°ï¼ˆè¡¨å•æ•°æ®ï¼‰â€‹â€

**å‚æ•°å**| **ç±»åž‹**| **å¿…ä¼ **| **ç¤ºä¾‹å€¼**| **è¯´æ˜Ž**  
---|---|---|---|---  
pdf_file| binary| æ˜¯| Happy-LLM.pdf| PDF æ–‡ä»¶äºŒè¿›åˆ¶æ•°æ®  
  
> **æ³¨** â€‹ï¼šéœ€ä½¿ç”¨ `multipart/form-data` æ ¼å¼ä¸Šä¼ æ–‡ä»¶ã€‚

### 2.4 å®Œæ•´ API ä½¿ç”¨ç¤ºä¾‹

Section titled â€œ2.4 å®Œæ•´ API ä½¿ç”¨ç¤ºä¾‹â€
    
    
    import os
    
    import json
    
    import requests
    
    
    
    
    import logging
    
    from typing import Optional
    
    
    
    
    
    
    
    logging.basicConfig(
    
        level=logging.INFO,
    
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    
    )
    
    logger = logging.getLogger("PDFParser")
    
    
    
    
    def pdf_parse_main(
    
        pdf_path: str,  # è¿™é‡Œä¿®æ”¹äº†è¯­æ³•é”™è¯¯
    
        parse_method: str = 'auto',
    
        model_json_path: Optional[str] = None,
    
        is_json_md_dump: bool = True,
    
        output_dir: Optional[str] = None,
    
        api_base_url: str = "https://d07031108-mineru070310-318-2zhtpekl-8000.550c.cloud"
    
    ):
    
        """
    
        é€šè¿‡è¿œç¨‹ API æ‰§è¡Œ PDF è½¬æ¢åˆ° JSONã€MD çš„è¿‡ç¨‹
    
    
    
    
        Args:
    
            pdf_path (str): PDF æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
    
            parse_method (str): è§£æžæ–¹æ³•ï¼Œæ”¯æŒ 'auto'ã€'ocr'ã€'txt' ä¸‰ç§æ¨¡å¼ï¼Œé»˜è®¤ä¸º 'auto'
    
                               - auto: è‡ªåŠ¨é€‰æ‹©æœ€ä½³è§£æžæ–¹å¼
    
                               - ocr: ä½¿ç”¨ OCR å…‰å­¦å­—ç¬¦è¯†åˆ«
    
                               - txt: æå–æ–‡æœ¬å†…å®¹
    
            model_json_path (str): é¢„è®­ç»ƒæ¨¡åž‹æ•°æ®æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
    
            is_json_md_dump (bool): æ˜¯å¦å°†è§£æžç»“æžœä¿å­˜ä¸º JSON å’Œ Markdown æ–‡ä»¶ï¼Œé»˜è®¤ä¸º True
    
            output_dir (str): è¾“å‡ºç›®å½•è·¯å¾„ï¼Œå¦‚æžœä¸º None åˆ™ä½¿ç”¨ PDF æ–‡ä»¶åŒçº§ç›®å½•
    
            api_base_url (str): API æœåŠ¡çš„åŸºç¡€ URL åœ°å€
    
    
    
    
        Returns:
    
            dict: åŒ…å«è§£æžç»“æžœçš„å­—å…¸ï¼Œå¦‚æžœå¤±è´¥åˆ™è¿”å›ž None
    
    
    
    
        Raises:
    
            FileNotFoundError: å½“ PDF æ–‡ä»¶ä¸å­˜åœ¨æ—¶æŠ›å‡º
    
            requests.RequestException: å½“ API è°ƒç”¨å¤±è´¥æ—¶æŠ›å‡º
    
        """
    
        try:
    
            # æ£€æŸ¥ PDF æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    
            if not os.path.exists(pdf_path):
    
                logger.error(f"PDF æ–‡ä»¶ä¸å­˜åœ¨ï¼š{pdf_path}")
    
                raise FileNotFoundError(f"PDF æ–‡ä»¶ä¸å­˜åœ¨ï¼š{pdf_path}")
    
    
    
    
            # å‡†å¤‡è¾“å‡ºç›®å½•ç»“æž„
    
            pdf_name = os.path.basename(pdf_path).rsplit(".", 1)[0]  # ä½¿ç”¨ rsplit å¤„ç†å¤šä¸ªç‚¹çš„æƒ…å†µ
    
            if output_dir:
    
                output_path = os.path.join(output_dir, pdf_name)
    
            else:
    
                # å¦‚æžœæ²¡æœ‰æŒ‡å®šè¾“å‡ºç›®å½•ï¼Œä½¿ç”¨ PDF æ–‡ä»¶æ‰€åœ¨ç›®å½•
    
                pdf_path_parent = os.path.dirname(pdf_path)
    
                output_path = os.path.join(pdf_path_parent, pdf_name)
    
    
    
    
            # åˆ›å»ºè¾“å‡ºç›®å½•
    
            os.makedirs(output_path, exist_ok=True)
    
            output_image_path = os.path.join(output_path, 'images')
    
            os.makedirs(output_image_path, exist_ok=True)
    
    
    
    
            logger.info(f"å¼€å§‹å¤„ç† PDF æ–‡ä»¶ï¼š{pdf_path}")
    
            logger.info(f"ä½¿ç”¨è§£æžæ–¹æ³•ï¼š{parse_method}")
    
            logger.info(f"è¾“å‡ºç›®å½•ï¼š{output_path}")
    
    
    
    
            # å‡†å¤‡ API è¯·æ±‚
    
            api_url = f"{api_base_url}/pdf_parse"  # ä¿®æ­£äº† API ç«¯ç‚¹ URL
    
    
    
    
            # å‡†å¤‡è¯·æ±‚å‚æ•° - ä½¿ç”¨ params ä¼ é€’æŸ¥è¯¢å‚æ•°
    
            params = {
    
                "parse_method": parse_method,
    
                "is_json_md_dump": str(is_json_md_dump).lower(),
    
                "output_dir": output_dir if output_dir else "output"
    
            }
    
    
    
    
            # å¦‚æžœæä¾›äº†æ¨¡åž‹ JSON è·¯å¾„ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
    
            if model_json_path and os.path.exists(model_json_path):
    
                params["model_json_path"] = model_json_path
    
                logger.info(f"ä½¿ç”¨æ¨¡åž‹æ–‡ä»¶ï¼š{model_json_path}")
    
    
    
    
            # å‡†å¤‡æ–‡ä»¶ä¸Šä¼ 
    
            files = {'pdf_file': open(pdf_path, 'rb')}
    
    
    
    
            logger.info("å¼€å§‹è°ƒç”¨è¿œç¨‹ API è¿›è¡Œ PDF è§£æž...")
    
    
    
    
            # å‘é€ API è¯·æ±‚
    
            try:
    
                response = requests.post(
    
                    api_url,
    
                    params=params,  # ä½¿ç”¨ params ä¼ é€’æŸ¥è¯¢å‚æ•°
    
                    files=files,
    
                    timeout=300  # è®¾ç½® 5 åˆ†é’Ÿè¶…æ—¶ï¼ŒPDF è§£æžå¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´
    
                )
    
    
    
    
                # æ£€æŸ¥å“åº”çŠ¶æ€
    
                response.raise_for_status()
    
    
    
    
            except requests.exceptions.Timeout:
    
                logger.error("API è¯·æ±‚è¶…æ—¶ï¼ŒPDF æ–‡ä»¶å¯èƒ½è¿‡å¤§æˆ–æœåŠ¡ç¹å¿™")
    
                return None
    
            except requests.exceptions.ConnectionError:
    
                logger.error(f"æ— æ³•è¿žæŽ¥åˆ° API æœåŠ¡ï¼š{api_base_url}")
    
                return None
    
            except requests.exceptions.HTTPError as e:
    
                logger.error(f"API è¯·æ±‚å¤±è´¥ï¼šHTTP {response.status_code} - {response.text}")
    
                return None
    
            finally:
    
                # ç¡®ä¿å…³é—­æ–‡ä»¶
    
                if 'pdf_file' in files:
    
                    files['pdf_file'].close()
    
    
    
    
            # è§£æž API å“åº”
    
            try:
    
                result_data = response.json()
    
                logger.info("API è°ƒç”¨æˆåŠŸï¼Œå¼€å§‹å¤„ç†è¿”å›žç»“æžœ")
    
            except json.JSONDecodeError:
    
                logger.error("API è¿”å›žçš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ— æ³•è§£æž JSON")
    
                return None
    
    
    
    
            # ä¿å­˜è§£æžç»“æžœåˆ°æœ¬åœ°æ–‡ä»¶
    
            if is_json_md_dump and _save_results_to_local(result_data, output_path, pdf_name):
    
                logger.info(f"è§£æžç»“æžœå·²ä¿å­˜åˆ°ï¼š{output_path}")
    
    
    
    
            logger.info("PDF è§£æžå®Œæˆ")
    
            return result_data
    
    
    
    
        except FileNotFoundError as e:
    
            logger.error(f"æ–‡ä»¶é”™è¯¯ï¼š{e}")
    
            return None
    
        except requests.RequestException as e:
    
            logger.error(f"ç½‘ç»œè¯·æ±‚é”™è¯¯ï¼š{e}")
    
            return None
    
        except Exception as e:
    
            logger.exception(f"å¤„ç† PDF æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼š{e}")
    
            return None
    
    
    
    
    
    
    
    def _save_results_to_local(result_data: dict, output_path: str, pdf_name: str) -> bool:
    
        """
    
        å°† API è¿”å›žçš„ç»“æžœä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶
    
    
    
    
        Args:
    
            result_data (dict): API è¿”å›žçš„è§£æžç»“æžœæ•°æ®
    
            output_path (str): è¾“å‡ºç›®å½•è·¯å¾„
    
            pdf_name (str): PDF æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰
    
    
    
    
        Returns:
    
            bool: ä¿å­˜æˆåŠŸè¿”å›ž Trueï¼Œå¤±è´¥è¿”å›ž False
    
        """
    
        try:
    
            # ä¿å­˜æ¨¡åž‹æ•°æ® JSON æ–‡ä»¶
    
            if 'model_list' in result_data:
    
                model_json_path = os.path.join(output_path, f"{pdf_name}_model.json")
    
                with open(model_json_path, 'w', encoding='utf-8') as f:
    
                    json.dump(result_data['model_list'], f, ensure_ascii=False, indent=4)
    
                logger.info(f"æ¨¡åž‹æ•°æ®å·²ä¿å­˜ï¼š{model_json_path}")
    
    
    
    
            # ä¿å­˜å†…å®¹åˆ—è¡¨ JSON æ–‡ä»¶
    
            if 'content_list' in result_data:
    
                content_json_path = os.path.join(output_path, f"{pdf_name}_content_list.json")
    
                with open(content_json_path, 'w', encoding='utf-8') as f:
    
                    json.dump(result_data['content_list'], f, ensure_ascii=False, indent=4)
    
                logger.info(f"å†…å®¹åˆ—è¡¨å·²ä¿å­˜ï¼š{content_json_path}")
    
    
    
    
            # ä¿å­˜ Markdown æ–‡ä»¶
    
            if 'markdown_content' in result_data:
    
                md_path = os.path.join(output_path, f"{pdf_name}.md")
    
                with open(md_path, 'w', encoding='utf-8') as f:
    
                    f.write(result_data['markdown_content'])
    
                logger.info(f"Markdown æ–‡ä»¶å·²ä¿å­˜ï¼š{md_path}")
    
    
    
    
            # ä¿å­˜å›¾ç‰‡æ–‡ä»¶ï¼ˆå¦‚æžœæœ‰ï¼‰
    
            if 'images' in result_data:
    
                images_dir = os.path.join(output_path, 'images')
    
                _save_images(result_data['images'], images_dir)
    
    
    
    
            return True
    
    
    
    
        except Exception as e:
    
            logger.error(f"ä¿å­˜ç»“æžœæ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯ï¼š{e}")
    
            return False
    
    
    
    
    
    
    
    def _save_images(images_data: dict, images_dir: str) -> None:
    
        """
    
        ä¿å­˜è§£æžè¿‡ç¨‹ä¸­æå–çš„å›¾ç‰‡æ–‡ä»¶
    
    
    
    
        Args:
    
            images_data (dict): åŒ…å«å›¾ç‰‡æ•°æ®çš„å­—å…¸
    
            images_dir (str): å›¾ç‰‡ä¿å­˜ç›®å½•
    
        """
    
        try:
    
            os.makedirs(images_dir, exist_ok=True)
    
    
    
    
            for image_name, image_content in images_data.items():
    
                image_path = os.path.join(images_dir, image_name)
    
    
    
    
                # å¦‚æžœå›¾ç‰‡å†…å®¹æ˜¯ base64 ç¼–ç ï¼Œéœ€è¦å…ˆè§£ç 
    
                if isinstance(image_content, str):
    
                    import base64
    
                    try:
    
                        image_content = base64.b64decode(image_content)
    
                    except base64.binascii.Error:
    
                        logger.warning(f"å›¾ç‰‡ {image_name} çš„ Base64 æ ¼å¼æ— æ•ˆ")
    
                        continue
    
    
    
    
                # ç¡®ä¿äºŒè¿›åˆ¶æ•°æ®å†™å…¥
    
                with open(image_path, 'wb') as f:
    
                    if isinstance(image_content, bytes):
    
                        f.write(image_content)
    
                    else:
    
                        logger.error(f"å›¾ç‰‡ {image_name} çš„å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„äºŒè¿›åˆ¶æ•°æ®")
    
    
    
    
                logger.info(f"å›¾ç‰‡å·²ä¿å­˜ï¼š{image_path}")
    
    
    
    
        except Exception as e:
    
            logger.error(f"ä¿å­˜å›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ï¼š{e}")
    
    
    
    
    
    
    
    def batch_pdf_parse(
    
        pdf_directory: str,
    
        parse_method: str = 'auto',
    
        output_dir: Optional[str] = None,
    
        api_base_url: str = "https://d07031108-mineru070310-318-2zhtpekl-8000.550c.cloud"
    
    ) -> dict:
    
        """
    
        æ‰¹é‡å¤„ç†ç›®å½•ä¸­çš„æ‰€æœ‰ PDF æ–‡ä»¶
    
    
    
    
        Args:
    
            pdf_directory (str): åŒ…å« PDF æ–‡ä»¶çš„ç›®å½•è·¯å¾„
    
            parse_method (str): è§£æžæ–¹æ³•ï¼Œé»˜è®¤ä¸º'auto'
    
            output_dir (str): è¾“å‡ºç›®å½•ï¼Œå¦‚æžœä¸º None åˆ™åœ¨æ¯ä¸ª PDF åŒçº§ç›®å½•åˆ›å»º
    
            api_base_url (str): API æœåŠ¡åœ°å€
    
    
    
    
        Returns:
    
            dict: åŒ…å«å¤„ç†ç»“æžœç»Ÿè®¡çš„å­—å…¸
    
        """
    
        if not os.path.exists(pdf_directory):
    
            logger.error(f"ç›®å½•ä¸å­˜åœ¨ï¼š{pdf_directory}")
    
            return {"success": 0, "failed": 0, "total": 0}
    
    
    
    
        # èŽ·å–ç›®å½•ä¸­æ‰€æœ‰ PDF æ–‡ä»¶
    
        pdf_files = [f for f in os.listdir(pdf_directory) if f.lower().endswith('.pdf')]
    
    
    
    
        if not pdf_files:
    
            logger.warning(f"ç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ° PDF æ–‡ä»¶ï¼š{pdf_directory}")
    
            return {"success": 0, "failed": 0, "total": 0}
    
    
    
    
        success_count = 0
    
        failed_count = 0
    
        total_count = len(pdf_files)
    
    
    
    
        logger.info(f"å¼€å§‹æ‰¹é‡å¤„ç†ï¼Œå…±æ‰¾åˆ° {total_count} ä¸ª PDF æ–‡ä»¶")
    
    
    
    
        for i, pdf_file in enumerate(pdf_files, 1):
    
            pdf_path = os.path.join(pdf_directory, pdf_file)
    
            logger.info(f"æ­£åœ¨å¤„ç†ç¬¬ {i}/{total_count} ä¸ªæ–‡ä»¶ï¼š{pdf_file}")
    
    
    
    
            try:
    
                result = pdf_parse_main(
    
                    pdf_path=pdf_path,
    
                    parse_method=parse_method,
    
                    output_dir=output_dir,
    
                    api_base_url=api_base_url
    
                )
    
    
    
    
                if result is not None:
    
                    success_count += 1
    
                    logger.info(f"æ–‡ä»¶å¤„ç†æˆåŠŸï¼š{pdf_file}")
    
                else:
    
                    failed_count += 1
    
                    logger.error(f"æ–‡ä»¶å¤„ç†å¤±è´¥ï¼š{pdf_file}")
    
    
    
    
            except Exception as e:
    
                failed_count += 1
    
                logger.error(f"å¤„ç†æ–‡ä»¶æ—¶å‘ç”Ÿå¼‚å¸¸ {pdf_file}: {str(e)}")
    
    
    
    
        result_summary = {
    
            "success": success_count,
    
            "failed": failed_count,
    
            "total": total_count
    
        }
    
    
    
    
        logger.info(f"æ‰¹é‡å¤„ç†å®Œæˆï¼šæˆåŠŸ {success_count}/{total_count}, å¤±è´¥ {failed_count}/{total_count}")
    
        return result_summary
    
    
    
    
    
    
    
    
    
    
    if __name__ == '__main__':
    
        # å•ä¸ªæ–‡ä»¶å¤„ç†ç¤ºä¾‹
    
        pdf_path = "book.pdf"  # è¿™é‡Œæ˜¯ä½ çš„ PDF æ–‡ä»¶å
    
    
    
    
        # æ£€æŸ¥ç¤ºä¾‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    
        if os.path.exists(pdf_path):
    
            logger.info("å¼€å§‹å¤„ç†ç¤ºä¾‹ PDF æ–‡ä»¶")
    
            result = pdf_parse_main(
    
                pdf_path=pdf_path,
    
                parse_method="auto",  # ä½¿ç”¨è‡ªåŠ¨è§£æžæ¨¡å¼
    
                output_dir="./output",  # æŒ‡å®šè¾“å‡ºç›®å½•
    
                is_json_md_dump=True  # ä¿å­˜ JSON å’Œ MD æ–‡ä»¶
    
            )
    
    
    
    
            if result:
    
                logger.info("PDF å¤„ç†å®Œæˆï¼Œç»“æžœå·²ä¿å­˜åˆ° output ç›®å½•")
    
                print(f"å¤„ç†ç»“æžœï¼š{result}")
    
            else:
    
                logger.error("PDF å¤„ç†å¤±è´¥")
    
        else:
    
            logger.warning(f"ç¤ºä¾‹æ–‡ä»¶ä¸å­˜åœ¨ï¼š{pdf_path}")
    
            logger.info("è¯·å°† PDF æ–‡ä»¶æ”¾åœ¨å½“å‰ç›®å½•ä¸‹ï¼Œæˆ–ä¿®æ”¹ pdf_path å˜é‡")
    
    
    
    
        # æ‰¹é‡å¤„ç†ç¤ºä¾‹ï¼ˆæ³¨é‡ŠæŽ‰ï¼Œéœ€è¦æ—¶å–æ¶ˆæ³¨é‡Šï¼‰
    
        # batch_result = batch_pdf_parse(
    
        #     pdf_directory="./pdf_files",
    
        #     parse_method="auto",
    
        #     output_dir="./batch_output"
    
        # )
    
        # logger.info(f"æ‰¹é‡å¤„ç†ç»“æžœï¼š{batch_result}")

> _æç¤ºï¼šä¸Šè¿°ä»£ç å±•ç¤ºäº†å®Œæ•´çš„å¤„ç†æµç¨‹ï¼ŒåŒ…æ‹¬:_
> 
>   * æ”¯æŒå¤šç§è§£æžæ–¹å¼ (auto/ocr/txt)
>   * è‡ªåŠ¨åˆ›å»ºè¾“å‡ºç›®å½•ç»“æž„
>   * ä¿å­˜æ¨¡åž‹ç»“æžœã€å†…å®¹åˆ—è¡¨å’Œ Markdown è¾“å‡º
>   * å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•
> 

